#pragma once
#include <cstdio>
#include <cstdlib>
#include <cstring>
constexpr int BUFFER_SIZE = 1024;

namespace Dream {
    class ostream final {
        template<class T>
        constexpr const ostream &overload(const char *format, T value) const noexcept {
            printf(format, value);
            return *this;
        }

    public:
        constexpr const ostream &operator<<(const int value) const noexcept { return overload("%d", value); }
        constexpr const ostream &operator<<(const unsigned int value) const noexcept { return overload("%u", value); }
        constexpr const ostream &operator<<(const long int value) const noexcept { return overload("%ld", value); }
        constexpr const ostream &operator<<(const unsigned long int value) const noexcept { return overload("%lu", value); }
        constexpr const ostream &operator<<(const long long int value) const noexcept { return overload("%lld", value); }
        constexpr const ostream &operator<<(const unsigned long long int value) const noexcept { return overload("%llu", value); }
        constexpr const ostream &operator<<(const float value) const noexcept { return overload("%f", value); }
        constexpr const ostream &operator<<(const double value) const noexcept { return overload("%f", value); }
        constexpr const ostream &operator<<(const long double value) const noexcept { return overload("%Lf", value); }
        constexpr const ostream &operator<<(const char value) const noexcept { return overload("%c", value); }
        constexpr const ostream &operator<<(const char *value) const noexcept { return overload("%s", value); }
        constexpr const ostream &operator<<(const void *value) const noexcept { return overload("%p", value); }
    };


    class istream final {
        template<class T>
        constexpr const istream &overload(const char *format, T value) const noexcept {
            scanf(format, value);
            return *this;
        }

    public:
        constexpr const istream &operator>>(int &value) const noexcept { return overload("%d", &value); }
        constexpr const istream &operator>>(unsigned int &value) const noexcept { return overload("%u", &value); }
        constexpr const istream &operator>>(long int &value) const noexcept { return overload("%ld", &value); }
        constexpr const istream &operator>>(unsigned long int &value) const noexcept { return overload("%lu", &value); }
        constexpr const istream &operator>>(long long int &value) const noexcept { return overload("%lld", &value); }
        constexpr const istream &operator>>(unsigned long long int &value) const noexcept { return overload("%llu", &value); }
        constexpr const istream &operator>>(float &value) const noexcept { return overload("%f", &value); }
        constexpr const istream &operator>>(double &value) const noexcept { return overload("%lf", &value); }
        constexpr const istream &operator>>(long double &value) const noexcept { return overload("%Lf", &value); }
        constexpr const istream &operator>>(char &value) const noexcept { return overload("%c", &value); }
        constexpr const istream &operator>>(char *value) const noexcept { return overload("%s", value); }
        constexpr const istream &operator>>(void *value) const noexcept { return overload("%p", value); }
    };


    template<class T>
    class allocator {
    public:
        allocator() noexcept = default;

        [[nodiscard]] constexpr T *allocate(const size_t size) const noexcept {
            if (T *res = (T *) malloc(size * sizeof(T))) {
                return res;
            }
            return nullptr;
        }

        constexpr void deallocate(T *ptr) const noexcept { free(ptr); }
        constexpr void construct(T *ptr, const T value) const noexcept { *ptr = value; }
        constexpr void destroy(T *ptr) const noexcept { ptr->~T(); }
    };


    template<class T, class Child>
    class iterator {
    protected:
        T *ptr_;

    public:
        iterator() noexcept = default;

        iterator(const T *value) noexcept : ptr_((T *) value) {}

        iterator(const iterator &itr) noexcept : ptr_(itr.ptr) {}

        constexpr Child &operator+(const size_t offset) const noexcept { return ptr_ + offset; }
        constexpr Child &operator-(const size_t offset) const noexcept { return ptr_ - offset; }
        constexpr size_t operator-(const iterator &other) const noexcept { return ptr_ - other.ptr; }
        constexpr bool operator==(const iterator &itr) const noexcept { return ptr_ == itr.ptr; }
        constexpr bool operator!=(const iterator &itr) const noexcept { return ptr_ != itr.ptr; }
        constexpr T &operator*() const noexcept { return *ptr_; }
        constexpr operator const void *() const noexcept { return (const void *) ptr_; }

        constexpr Child &operator=(const T value) noexcept {
            *ptr_ = value;
            return *this;
        }

        constexpr Child &operator=(const iterator &other) noexcept {
            if (this == &other) {
                return *this;
            }
            ptr_ = other.ptr;
            return *this;
        }

        constexpr Child &operator++() noexcept {
            ++ptr_;
            return *this;
        }

        constexpr Child operator++(int) noexcept {
            Child temp = *this;
            ++ptr_;
            return temp;
        }

        constexpr Child &operator--() noexcept {
            --ptr_;
            return *this;
        }

        constexpr Child operator--(int) noexcept {
            Child temp = *this;
            --ptr_;
            return temp;
        }

        constexpr Child &operator+=(const size_t offset) noexcept {
            ptr_ += offset;
            return *this;
        }

        constexpr Child &operator-=(const size_t offset) noexcept {
            ptr_ -= offset;
            return *this;
        }
    };


    template<class T, class Child>
    class reverse_iterator : public iterator<T, reverse_iterator<T, Child>> {
    protected:
        using iterator<T, reverse_iterator>::ptr_;

    public:
        using iterator<T, reverse_iterator>::iterator;

        constexpr Child &operator++() noexcept {
            --ptr_;
            return *this;
        }

        constexpr Child operator++(int) noexcept {
            Child temp = *this;
            --ptr_;
            return temp;
        }

        constexpr Child &operator--() noexcept {
            ++ptr_;
            return *this;
        }

        Child operator--(int) noexcept {
            Child temp = *this;
            ++ptr_;
            return temp;
        }

        constexpr Child &operator+=(const size_t offset) noexcept {
            ptr_ -= offset;
            return *this;
        }

        constexpr Child &operator-=(const size_t offset) noexcept {
            ptr_ += offset;
            return *this;
        }
    };


    class string {
        char *buffer_ = nullptr;
        size_t capacity_ = 0, size_ = 0;
        allocator<char> alloc_ = allocator<char>();

    public:
        class iterator final : public Dream::iterator<char, iterator> {
        public:
            using Dream::iterator<char, iterator>::iterator;
        };

        class reverse_iterator final : public Dream::reverse_iterator<char, reverse_iterator> {
        public:
            using Dream::reverse_iterator<char, reverse_iterator>::reverse_iterator;
        };

        class const_iterator final : public Dream::iterator<const char, const_iterator> {
        public:
            using iterator::iterator;
        };

        class const_reverse_iterator final : public Dream::reverse_iterator<const char, const_reverse_iterator> {
        public:
            using reverse_iterator::reverse_iterator;
        };

        string(const char *other) noexcept : string(other, allocator<char>()) {}

        string(const string &other, const size_t pos, const size_t len) noexcept : string(other.begin() + pos, other.begin() + pos + len) {}

        string(const size_t num, const char other) noexcept : string(num, other, allocator<char>()) {}

        string(const string &other) noexcept : string(other, allocator<char>()) {}

        string(const iterator &first, const iterator &last) noexcept : string(first, last, allocator<char>()) {}

        string() noexcept : buffer_(nullptr), capacity_(0), size_(0) {}

        string(string &&other) noexcept : buffer_(other.buffer_), capacity_(other.capacity_), size_(other.size_) { other = string(); }

        string(const char *other, const size_t len) noexcept {
            if (other) {
                size_ = len;
                capacity_ = size_ + 1;

                if ((buffer_ = alloc_.allocate(capacity_ * sizeof(char)))) {
                    memcpy(buffer_, other, size_);
                    buffer_[size_] = 0;
                } else {
                    *this = string();
                }
            } else {
                *this = string();
            }
        }

        string(const char *other, const allocator<char> &alloc) noexcept {
            if (other) {
                size_ = strlen(other);
                capacity_ = size_ + 1;
                alloc_ = alloc;

                if ((buffer_ = alloc.allocate(capacity_ * sizeof(char)))) {
                    memcpy(buffer_, other, size_);
                    buffer_[size_] = 0;
                } else {
                    *this = string();
                }
            } else {
                *this = string();
            }
        }

        string(const size_t num, const char other, const allocator<char> &alloc) noexcept {
            size_ = num;
            capacity_ = size_ + 1;
            buffer_ = alloc.allocate(capacity_ * sizeof(char));
            alloc_ = alloc;

            if (buffer_) {
                for (int i = 0; i < num; i++) {
                    buffer_[i] = other;
                }
                buffer_[size_] = 0;
            } else {
                *this = string();
            }
        }

        string(const string &other, const allocator<char> &alloc) noexcept : capacity_(other.capacity_), size_(other.size_) {
            alloc_ = alloc;
            buffer_ = alloc.allocate(other.capacity_ * sizeof(char));

            if (buffer_ && other.buffer_) {
                memcpy(buffer_, other.buffer_, other.capacity_);
            } else {
                *this = string();
            }
        }

        string(string &&other, const allocator<char> &alloc) noexcept : capacity_(other.capacity_), size_(other.size_) {
            alloc_ = alloc;
            alloc_.deallocate(buffer_);

            if ((buffer_ = alloc_.allocate(capacity_ * sizeof(char)))) {
                memcpy(buffer_, other.buffer_, size_);
                buffer_[size_] = 0;
            } else {
                *this = nullptr;
            }
            other = string();
        }

        string(const iterator &first, const iterator &last, const allocator<char> &alloc) noexcept {
            alloc_ = alloc;
            size_ = last - first;
            capacity_ = size_ + 1;

            if ((buffer_ = alloc_.allocate(capacity_ * sizeof(char)))) {
                memcpy(buffer_, first, size_);
                buffer_[size_] = 0;
            } else {
                *this = string();
            }
        }

        constexpr string &operator=(const string &other) noexcept {
            if (this == &other) {
                return *this;
            }
            alloc_.deallocate(buffer_);
            *this = string(other.begin(), other.end());
            return *this;
        }

        constexpr string &operator=(string &&other) noexcept {
            if (this == &other) {
                capacity_ = other.capacity_;
                size_ = other.size_;
                alloc_.deallocate(buffer_);
                buffer_ = other.buffer_;
                other.buffer_ = alloc_.allocate(1 * sizeof(char));
                other.buffer_[0] = 0;
                other.capacity_ = 1;
                other.size_ = 0;
            }
            return *this;
        }

        constexpr string &operator=(const char *other) noexcept {
            alloc_.deallocate(buffer_);
            *this = string(other);
            return *this;
        }

        constexpr string &operator=(const char other) noexcept {
            alloc_.deallocate(buffer_);
            *this = string(1, other);
            return *this;
        }

        constexpr friend const ostream &operator<<(const ostream &stream, const string &str) noexcept {
            stream << str.buffer_;
            return stream;
        }

        constexpr friend const istream &operator>>(const istream &stream, string &str) noexcept {
            char buffer[BUFFER_SIZE];

            if (fgets(buffer, sizeof(buffer), stdin)) {
                const size_t len = strlen(buffer);

                if (buffer[len - 1] == '\n') {
                    buffer[len - 1] = 0;
                }
                str = string(buffer, buffer + len);
            }
            return stream;
        }

        [[nodiscard]] constexpr iterator begin() const noexcept { return buffer_; }
        [[nodiscard]] constexpr iterator end() const noexcept { return buffer_ + size_; }
        [[nodiscard]] constexpr reverse_iterator rbegin() const noexcept { return buffer_ + size_ - 1; }
        [[nodiscard]] constexpr reverse_iterator rend() const noexcept { return buffer_ - 1; }
        [[nodiscard]] constexpr const_iterator cbegin() const noexcept { return buffer_; }
        [[nodiscard]] constexpr const_iterator cend() const noexcept { return buffer_ + size_; }
        [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept { return buffer_ + size_ - 1; }
        [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept { return buffer_ - 1; }

        string &append(const string &other);

        string &append(const string &other, size_t sub_pos, size_t sub_len);

        string &append(const char *other);

        string &append(const char *other, size_t num);

        string &append(size_t num, const char other);

        string &append(const iterator &first, const iterator &last);

        string &append(const string &other, size_t num);

        string &assign(const string &other);

        string &assign(const string &other, size_t sub_pos, size_t sub_len);

        string &assign(const char *other);

        string &assign(const char *other, size_t num);

        string &assign(size_t num, const char other);

        string &assign(const iterator &first, const iterator &last);

        string &assign(const string &other, size_t num);

        char &at(size_t num);

        const char &at(size_t num) const;

        char &back();

        const char *c_str();

        // size_t capacity();

        void clear();

        int compare(const string &other);

        int compare(size_t pos, size_t len, const string &other);

        int compare(size_t pos, size_t len, const string &str, size_t subpos, size_t sublen);

        int compare(const char *s);

        int compare(size_t pos, size_t len, const char *s);

        int compare(size_t pos, size_t len, const char *s, size_t n);

        size_t copy(const char *other, size_t len, size_t pos);

        char *data();

        bool empty();

        bool ends_with(const string &suffix);

        bool ends_with(const char *suffix);

        bool ends_with(char ch);

        iterator &erase(const_iterator &pos);

        iterator &erase(const_iterator &first, const_iterator &last);

        string &erase(size_t pos, size_t count);

        size_t find(const string &other, size_t pos);

        size_t find(const char *other, size_t pos);

        size_t find(const char *other, size_t pos, size_t count);

        size_t find(char ch, size_t pos);

        size_t find_first_not_of(const string &other, size_t pos);

        size_t find_first_not_of(const char *other, size_t pos);

        size_t find_first_not_of(const char *other, size_t pos, size_t count);

        size_t find_first_not_of(char ch, size_t pos);

        size_t find_first_of(const string &other, size_t pos);

        size_t find_first_of(const char *other, size_t pos);

        size_t find_first_of(const char *other, size_t pos, size_t count);

        size_t find_first_of(char ch, size_t pos);

        size_t find_last_not_of(const string &other, size_t pos);

        size_t find_last_not_of(const char *other, size_t pos);

        size_t find_last_not_of(const char *other, size_t pos, size_t count);

        size_t find_last_not_of(char ch, size_t pos);

        size_t find_last_of(const string &other, size_t pos);

        size_t find_last_of(const char *other, size_t pos);

        size_t find_last_of(const char *other, size_t pos, size_t count);

        size_t find_last_of(char ch, size_t pos);

        char &front();

        allocator<char> get_allocator();

        string &insert(size_t pos, const string &other);

        string &insert(size_t pos, const string &str, size_t sub_pos, size_t sub_len);

        string &insert(size_t pos, const char *other);

        string &insert(size_t pos, const char *other, size_t num);

        string &insert(size_t pos, size_t num, char ch);

        iterator insert(const_iterator first, char ch);

        iterator insert(const_iterator first, size_t num, char ch);

        iterator insert(const_iterator p, iterator first, iterator last);

        size_t length();

        void pop_back();

        void push_back(const char ch);

        string &replace(const_iterator start, const_iterator end, const char *other);

        string &replace(const_iterator start, const_iterator end, const string &other);

        constexpr void reserve(const size_t new_capacity) noexcept {
            if (new_capacity > capacity_) {
                if (char *new_buffer = alloc_.allocate(new_capacity * sizeof(char))) {
                    memcpy(new_buffer, buffer_, size_ + 1);
                    alloc_.deallocate(buffer_);
                    buffer_ = new_buffer;
                    capacity_ = new_capacity;
                }
            }
        }

        ~string() noexcept {
            if (buffer_) {
                alloc_.deallocate(buffer_);
            }
            buffer_ = nullptr;
        }
    };


    constexpr ostream cout;
    constexpr istream cin;
    constexpr char endl = '\n';
} // namespace Dream
