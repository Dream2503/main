#include <stdio.h>
#include <stdlib.h>
#include <string.h>
constexpr int BUFFER_SIZE = 1024;

namespace Dream {
    
    class ostream final {
        template <class T>
        const ostream& overload(const char* format, T value) const noexcept {
            printf(format, value);
            return *this;
        }

        public:
            const ostream& operator<<(const int value) const noexcept { return overload("%d", value); }
            const ostream& operator<<(const unsigned int value) const noexcept { return overload("%u", value); }
            const ostream& operator<<(const long int value) const noexcept { return overload("%ld", value); }
            const ostream& operator<<(const unsigned long int value) const noexcept { return overload("%lu", value); }
            const ostream& operator<<(const long long int value) const noexcept { return overload("%lld", value); }
            const ostream& operator<<(const unsigned long long int value) const noexcept { return overload("%llu", value); }
            const ostream& operator<<(const float value) const noexcept { return overload("%f", value); }
            const ostream& operator<<(const double value) const noexcept { return overload("%f", value); }
            const ostream& operator<<(const long double value) const { return overload("%Lf", value); }
            const ostream& operator<<(const char value) const noexcept { return overload("%c", value); }
            const ostream& operator<<(const char* value) const noexcept { return overload("%s", value); }
            const ostream& operator<<(const void* value) const noexcept { return overload("%p", value); }
    };


    class istream final {
        template <class T>
        const istream& overload(const char* format, T value) const noexcept {
            scanf(format, value);
            return *this;
        }

        public:
            const istream& operator>>(int& value) const noexcept { return overload("%d", &value); }
            const istream& operator>>(unsigned int& value) const noexcept { return overload("%u", &value); }
            const istream& operator>>(long int& value) const noexcept { return overload("%ld", &value); }
            const istream& operator>>(unsigned long int& value) const noexcept { return overload("%lu", &value); }
            const istream& operator>>(long long int& value) const noexcept { return overload("%lld", &value); }
            const istream& operator>>(unsigned long long int& value) const noexcept { return overload("%llu", &value); }
            const istream& operator>>(float& value) const noexcept { return overload("%f", &value); }
            const istream& operator>>(double& value) const noexcept { return overload("%lf", &value); }
            const istream& operator>>(long double& value) const noexcept { return overload("%Lf", &value); }
            const istream& operator>>(char& value) const noexcept { return overload("%c", &value); }
            const istream& operator>>(char* value) const noexcept { return overload("%s", value); }
            const istream& operator>>(void* value) const noexcept { return overload("%p", value); }
    };


    template <class T, class Child>
    class iterator {
        protected:
            T* ptr;

        public:
            iterator() noexcept = default;
            iterator(const T* value) noexcept: ptr((T*)value) {}
            iterator(const iterator& itr) noexcept: ptr(itr.ptr) {}
            Child operator+(const size_t offset) const noexcept { return Child(ptr + offset); }
            Child operator-(const size_t offset) const noexcept { return Child(ptr - offset); }
            size_t operator-(const iterator& other) const noexcept { return ptr - other.ptr; }
            bool operator==(const iterator& itr) const noexcept { return ptr == itr.ptr; }
            bool operator!=(const iterator& itr) const noexcept { return ptr != itr.ptr; }
            T& operator*() const noexcept { return *ptr; }
            operator const void*() const noexcept { return (const void*)ptr; }

            Child& operator=(const T value) noexcept {
                *ptr = value;
                return *((Child*)this);
            }

            Child& operator=(const iterator& other) noexcept {
                ptr = other.ptr;
                return *((Child*)this);
            }

            Child& operator++() noexcept {
                ++ptr;
                return *((Child*)this);
            }

            Child operator++(int) noexcept {
                Child temp = *((Child*)this);
                ptr++;
                return temp;
            }

            Child& operator--() noexcept {
                --ptr;
                return *((Child*)this);
            }

            Child operator--(int) noexcept {
                Child temp = *((Child*)this);
                ptr--;
                return temp;
            }

            Child& operator+=(size_t offset) noexcept {
                ptr += offset;
                return *((Child*)this);
            }

            Child& operator-=(size_t offset) noexcept {
                ptr -= offset;
                return *((Child*)this);
            }
    };


    template <class T, class Child>
    class reverse_iterator: public iterator<T, reverse_iterator<T, Child>> {
        protected:
            using iterator<T, reverse_iterator>::ptr;

        public:
            using iterator<T, reverse_iterator>::iterator;

            Child& operator++() noexcept {
                --this->ptr;
                return *((Child*)this);
            }

            Child operator++(int) noexcept {
                Child temp = *((Child*)this);
                this->ptr--;
                return temp;
            }

            Child& operator--() noexcept {
                ++this->ptr;
                return *((Child*)this);
            }

            Child operator--(int) noexcept {
                Child temp = *((Child*)this);
                this->ptr++;
                return temp;
            }

            Child& operator+=(size_t offset) noexcept {
                this->ptr -= offset;
                return *((Child*)this);
            }

            Child& operator-=(size_t offset) noexcept {
                this->ptr += offset;
                return *((Child*)this);
            }
    };


    template <class T>
    class allocator {
        public:
            allocator() noexcept = default;
            T* allocate(size_t size) const noexcept {
                T* res = (T*)malloc(size * sizeof(T));

                if (res) {
                    return res;
                } else {
                    return nullptr;
                }
            }

            void deallocate(T* ptr, size_t size) const noexcept { free(ptr); }
            void construct(T* ptr, T value) const noexcept { *ptr = value; }
            void destroy(T* ptr) const noexcept { ptr->~T(); }
    };


    class string {
        char* buffer;
        size_t capacity, size;
        allocator<char> alloc = allocator<char>();

        public:
            class iterator final: public Dream::iterator<char, iterator> {
                public: using Dream::iterator<char, iterator>::iterator;
            };

            class reverse_iterator final: public Dream::reverse_iterator<char, reverse_iterator> {
                public: using Dream::reverse_iterator<char, reverse_iterator>::reverse_iterator;
            };

            class const_iterator final: public Dream::iterator<const char, const_iterator> {
                public: using Dream::iterator<const char, const_iterator>::iterator;
            };

            class const_reverse_iterator final: public Dream::reverse_iterator<const char, const_reverse_iterator> {
                public: using Dream::reverse_iterator<const char, const_reverse_iterator>::reverse_iterator;
            };

            string(const char* other) noexcept: string(other, allocator<char>()) {}
            string(const string& other, const size_t pos, const size_t len) noexcept: string(other.begin() + pos, other.begin() + pos + len) {}
            string(const size_t num, const char other) noexcept: string(num, other, allocator<char>()) {}
            string(const string &other) noexcept: string(other, allocator<char>()) {}
            string(const iterator& first, const iterator& last) noexcept: string(first, last, allocator<char>()) {}

            string() noexcept: capacity(1), size(0) {
                buffer = (char*)malloc(1 * sizeof(char));

                if (buffer) {
                    buffer[0] = 0;
                } else {
		            buffer = nullptr;
		            capacity = size = 0;
                }
            }

            string(string&& other) noexcept: buffer(other.buffer), capacity(other.capacity), size(other.size) {
                other.buffer = nullptr;
                other.capacity = other.size = 0;
            }
            
            string(const char* other, const size_t len) noexcept {
                if (other) {
                    size = len;
                    capacity = size + 1;
                    buffer = (char*)malloc(capacity * sizeof(char));

                    if (buffer) {
                        memcpy(buffer, other, size);
                        buffer[size] = 0;
                    } else {
                        string();
                    }
                } else {
                    string();
                }
            }

            string(const char* other, const allocator<char>& alloc) {
                if (other) {
                    size = strlen(other);
                    capacity = size + 1;
                    buffer = alloc.allocate(capacity);
                    memcpy(buffer, other, size);
                    buffer[size] = 0;
                    this->alloc = alloc;
                } else {
                    string();
                }
            }

            string(size_t num, const char other, const allocator<char>& alloc) noexcept {
                size = num;
                capacity = size + 1;
                buffer = alloc.allocate(capacity);
                this->alloc = alloc;

                if (buffer) {
                    for (int i = 0; i < num; i++) {
                        buffer[i] = other;
                    }
                    buffer[num] = 0;
                } else {
                    string();
                }
            }

            string(const string &other, const allocator<char>& alloc) noexcept: capacity(other.capacity), size(other.size) {
                buffer = alloc.allocate(other.capacity);
                this->alloc = alloc;

                if (buffer && other.buffer) {
                    memcpy(buffer, other.buffer, other.capacity);
                } else {
                    string();
                }
            }

            string(string&& other, const allocator<char>& alloc) noexcept: buffer(other.buffer), capacity(other.capacity), size(other.size) {
                free(buffer);
                buffer = alloc.allocate(capacity);
                this->alloc = alloc;
                memcpy(buffer, other.buffer, size);
                buffer[size] = 0;
                other.buffer = nullptr;
                other.capacity = other.size = 0;
            }

            string(const iterator& first, const iterator& last, const allocator<char>& alloc) noexcept {
                size = last - first;
                capacity = size + 1;
                buffer = alloc.allocate(capacity);
                this->alloc = alloc;
                memcpy(buffer, first, size);
                buffer[size] = 0;
            }

            string& operator=(const string& other) noexcept {
                free(buffer);
                *this = string(other.begin(), other.end());
                return *this;
            }

            string& operator=(string&& other) noexcept {
                if (this != &other) {
                    free(buffer);
                    buffer = other.buffer;
                    size = other.size;
                    capacity = other.capacity;
                    other.buffer = nullptr;
                    other.size = other.capacity = 0;
                }
                return *this;
            }

            string& operator=(const char* other) noexcept {
                free(buffer);
                *this = string(other);
                return *this;
            }

            string& operator=(const char other) noexcept {
                free(buffer);
                *this = string(1, other);
                return *this;
            }
            
            friend const ostream& operator<<(const ostream& stream, const string& str) noexcept {
                stream << str.buffer;
                return stream;
            }

            friend const istream& operator>>(const istream& stream, string& str) noexcept {
                char buffer[BUFFER_SIZE];

                if (fgets(buffer, sizeof(buffer), stdin)) {
                    size_t len = strlen(buffer);

                    if (buffer[len - 1] == '\n') {
                        buffer[len - 1] = '\0';
                    }
                    str = string(buffer, buffer + len); 
                }
                return stream;
            }

            iterator begin() const noexcept { return iterator(buffer); }
            iterator end() const noexcept { return iterator(buffer + size); }
            reverse_iterator rbegin() const noexcept { return reverse_iterator(buffer + size - 1); }
            reverse_iterator rend() const noexcept { return reverse_iterator(buffer - 1); }
            const_iterator cbegin() const noexcept { return const_iterator(buffer); }
            const_iterator cend() const noexcept { return const_iterator(buffer + size); }
            const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(buffer + size - 1); }
            const_reverse_iterator crend() const noexcept { return const_reverse_iterator(buffer - 1); }

            string& append(const string& other);
            string& append(const string& other, size_t sub_pos, size_t sub_len);
            string& append(const char* other);
            string& append(const char* other, size_t num);
            string& append(size_t num, const char other);
            string& append(const iterator& first, const iterator& last);
            string& append(const string& other, size_t num);

            string& assign(const string& other);
            string& assign(const string& other, size_t sub_pos, size_t sub_len);
            string& assign(const char* other);
            string& assign(const char* other, size_t num);
            string& assign(size_t num, const char other);
            string& assign(const iterator& first, const iterator& last);
            string& assign(const string& other, size_t num);

            char& at(size_t num);
            const char& at(size_t num) const; 

            char& back();

            const char* c_str();

            size_t capacity();

            void clear();

            int compare(const string& other);
            int compare(size_t pos, size_t len, const string& other);
            int compare(size_t pos, size_t len, const string& str, size_t subpos, size_t sublen);
            int compare(const char* s);
            int compare(size_t pos, size_t len, const char* s);
            int compare(size_t pos, size_t len, const char* s, size_t n);

            size_t copy(const char* other, size_t len, size_t pos);

            char* data();

            bool empty();

            bool ends_with(const string& suffix);
            bool ends_with(const char* suffix);
            bool ends_with(char ch);

            iterator& erase(const_iterator& pos);
            iterator& erase(const_iterator& first, const_iterator& last);
            string& erase(size_t pos, size_t count);

            size_t find(const string& other, size_t pos);
            size_t find(const char* other, size_t pos);
            size_t find(const char* other, size_t pos, size_t count);
            size_t find(char ch, size_t pos);

            size_t find_first_not_of(const string& other, size_t pos);
            size_t find_first_not_of(const char* other, size_t pos);
            size_t find_first_not_of(const char* other, size_t pos, size_t count);
            size_t find_first_not_of(char ch, size_t pos);

            size_t find_first_of(const string& other, size_t pos);
            size_t find_first_of(const char* other, size_t pos);
            size_t find_first_of(const char* other, size_t pos, size_t count);
            size_t find_first_of(char ch, size_t pos);

            size_t find_last_not_of(const string& other, size_t pos);
            size_t find_last_not_of(const char* other, size_t pos);
            size_t find_last_not_of(const char* other, size_t pos, size_t count);
            size_t find_last_not_of(char ch, size_t pos);

            size_t find_last_of(const string& other, size_t pos);
            size_t find_last_of(const char* other, size_t pos);
            size_t find_last_of(const char* other, size_t pos, size_t count);
            size_t find_last_of(char ch, size_t pos);

            char& front();

            allocator<char> get_allocator();

            string& insert(size_t pos, const string& other);
            string& insert(size_t pos, const string& str, size_t sub_pos, size_t sub_len);
            string& insert(size_t pos, const char* other);
            string& insert(size_t pos, const char* other, size_t num);
            string& insert(size_t pos, size_t num, char ch);
            iterator insert(const_iterator first, char ch);
            iterator insert(const_iterator first, size_t num, char ch);
            iterator insert(const_iterator p, iterator first, iterator last);

            size_t length();

            void pop_back();

            void push_back(const char ch);

            string& replace(const_iterator start, const_iterator end, const char* other);
            string& replace(const_iterator start, const_iterator end, const string& other);

            void reserve(size_t new_capacity) noexcept {
                if (new_capacity > capacity) {
                    char* new_buffer = (char*)malloc(new_capacity * sizeof(char));

                    if (new_buffer) {
                        memcpy(new_buffer, buffer, size + 1);
                        free(buffer);
                        buffer = new_buffer;
                        capacity = new_capacity;
                    }
                }
            }
            
            ~string() noexcept {
                if (buffer) {
                    free(buffer);
                }
                buffer = nullptr;
            }
    };

    
    const ostream cout;
    const istream cin;
    const char endl = '\n';
}
