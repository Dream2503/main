#pragma once
#include <cstdio>
#include <cstdlib>
#include <cstring>
constexpr int BUFFER_SIZE = 1024;

namespace Dream {
    class ostream final {
        template<class T>
        const ostream &overload(const char *format, T value) const noexcept {
            printf(format, value);
            return *this;
        }

    public:
        const ostream &operator<<(const int value) const noexcept { return overload("%d", value); }
        const ostream &operator<<(const unsigned int value) const noexcept { return overload("%u", value); }
        const ostream &operator<<(const long int value) const noexcept { return overload("%ld", value); }
        const ostream &operator<<(const unsigned long int value) const noexcept { return overload("%lu", value); }
        const ostream &operator<<(const long long int value) const noexcept { return overload("%lld", value); }
        const ostream &operator<<(const unsigned long long int value) const noexcept { return overload("%llu", value); }
        const ostream &operator<<(const float value) const noexcept { return overload("%f", value); }
        const ostream &operator<<(const double value) const noexcept { return overload("%f", value); }
        const ostream &operator<<(const long double value) const { return overload("%Lf", value); }
        const ostream &operator<<(const char value) const noexcept { return overload("%c", value); }
        const ostream &operator<<(const char *value) const noexcept { return overload("%s", value); }
        const ostream &operator<<(const void *value) const noexcept { return overload("%p", value); }
    };


    class istream final {
        template<class T>
        const istream &overload(const char *format, T value) const noexcept {
            scanf(format, value);
            return *this;
        }

    public:
        const istream &operator>>(int &value) const noexcept { return overload("%d", &value); }
        const istream &operator>>(unsigned int &value) const noexcept { return overload("%u", &value); }
        const istream &operator>>(long int &value) const noexcept { return overload("%ld", &value); }
        const istream &operator>>(unsigned long int &value) const noexcept { return overload("%lu", &value); }
        const istream &operator>>(long long int &value) const noexcept { return overload("%lld", &value); }
        const istream &operator>>(unsigned long long int &value) const noexcept { return overload("%llu", &value); }
        const istream &operator>>(float &value) const noexcept { return overload("%f", &value); }
        const istream &operator>>(double &value) const noexcept { return overload("%lf", &value); }
        const istream &operator>>(long double &value) const noexcept { return overload("%Lf", &value); }
        const istream &operator>>(char &value) const noexcept { return overload("%c", &value); }
        const istream &operator>>(char *value) const noexcept { return overload("%s", value); }
        const istream &operator>>(void *value) const noexcept { return overload("%p", value); }
    };


    template<class T, class Child = Dream::iterator>
    class iterator {
    protected:
        T *ptr;

    public:
        iterator() noexcept = default;

        iterator(const T *value) noexcept: ptr((T *) value) {
        }

        iterator(const iterator &itr) noexcept: ptr(itr.ptr) {
        }

        Child operator+(const size_t offset) const noexcept { return Child(ptr + offset); }
        Child operator-(const size_t offset) const noexcept { return Child(ptr - offset); }
        size_t operator-(const iterator &other) const noexcept { return ptr - other.ptr; }
        bool operator==(const iterator &itr) const noexcept { return ptr == itr.ptr; }
        bool operator!=(const iterator &itr) const noexcept { return ptr != itr.ptr; }
        T &operator*() const noexcept { return *ptr; }
        operator const void *() const noexcept { return (const void *) ptr; }

        Child &operator=(const T value) noexcept {
            *ptr = value;
            return *((Child *) this);
        }

        Child &operator=(const iterator &other) noexcept {
            if (this == &other) {
                return *this;
            }
            ptr = other.ptr;
            return *((Child *) this);
        }

        Child &operator++() noexcept {
            ++ptr;
            return *((Child *) this);
        }

        Child operator++(int) noexcept {
            Child temp = *((Child *) this);
            ++ptr;
            return temp;
        }

        Child &operator--() noexcept {
            --ptr;
            return *((Child *) this);
        }

        Child operator--(int) noexcept {
            Child temp = *((Child *) this);
            --ptr;
            return temp;
        }

        Child &operator+=(size_t offset) noexcept {
            ptr += offset;
            return *((Child *) this);
        }

        Child &operator-=(size_t offset) noexcept {
            ptr -= offset;
            return *((Child *) this);
        }
    };


    template<class T, class Child>
    class reverse_iterator : public iterator<T, reverse_iterator<T, Child> > {
    protected:
        using iterator<T, reverse_iterator>::ptr;

    public:
        using iterator<T, reverse_iterator>::iterator;

        Child &operator++() noexcept {
            --this->ptr;
            return *((Child *) this);
        }

        Child operator++(int) noexcept {
            Child temp = *((Child *) this);
            --this->ptr;
            return temp;
        }

        Child &operator--() noexcept {
            ++this->ptr;
            return *((Child *) this);
        }

        Child operator--(int) noexcept {
            Child temp = *((Child *) this);
            ++this->ptr;
            return temp;
        }

        Child &operator+=(size_t offset) noexcept {
            this->ptr -= offset;
            return *((Child *) this);
        }

        Child &operator-=(size_t offset) noexcept {
            this->ptr += offset;
            return *((Child *) this);
        }
    };


    template<class T>
    class allocator {
    public:
        allocator() noexcept = default;

        [[nodiscard]] T *allocate(const size_t size) const noexcept {
            if (T *res = (T *) malloc(size * sizeof(T))) {
                return res;
            }
            return nullptr;
        }

        void deallocate(T *ptr) noexcept { free(ptr); }
        void construct(T *ptr, T value) noexcept { *ptr = value; }
        void destroy(T *ptr) noexcept { ptr->~T(); }
    };


    class string {
        char *buffer;
        size_t capacity, size;
        allocator<char> alloc = allocator<char>();

    public:
        class iterator final : public Dream::iterator<char, iterator> {
        public:
            using Dream::iterator<char, iterator>::iterator;
        };

        class reverse_iterator final : public Dream::reverse_iterator<char, reverse_iterator> {
        public:
            using Dream::reverse_iterator<char, reverse_iterator>::reverse_iterator;
        };

        class const_iterator final : public Dream::iterator<const char, const_iterator> {
        public:
            using iterator::iterator;
        };

        class const_reverse_iterator final : public Dream::reverse_iterator<const char, const_reverse_iterator> {
        public:
            using reverse_iterator::reverse_iterator;
        };

        string(const char *other) noexcept: string(other, allocator<char>()) {
        }

        string(const string &other, const size_t pos, const size_t len) noexcept: string(
            other.begin() + pos, other.begin() + pos + len) {
        }

        string(const size_t num, const char other) noexcept: string(num, other, allocator<char>()) {
        }

        string(const string &other) noexcept: string(other, allocator<char>()) {
        }

        string(const iterator &first, const iterator &last) noexcept: string(first, last, allocator<char>()) {
        }

        string() noexcept: capacity(1), size(0) {
            if ((buffer = alloc.allocate(1))) {
                buffer[0] = 0;
            } else {
                buffer = nullptr;
                capacity = size = 0;
            }
        }

        string(string &&other) noexcept: buffer(other.buffer), capacity(other.capacity), size(other.size) {
            other = string();
        }

        string(const char *other, const size_t len) noexcept {
            if (other) {
                size = len;
                capacity = size + 1;
                buffer = alloc.allocate(capacity * sizeof(char));

                if (buffer) {
                    memcpy(buffer, other, size);
                    buffer[size] = 0;
                } else {
                    string();
                }
            } else {
                string();
            }
        }

        string(const char *other, const allocator<char> &alloc) {
            if (other) {
                size = strlen(other);
                capacity = size + 1;
                buffer = alloc.allocate(capacity * sizeof(char));
                memcpy(buffer, other, size);
                buffer[size] = 0;
                this->alloc = alloc;
            } else {
                string();
            }
        }

        string(const size_t num, const char other, const allocator<char> &alloc) noexcept {
            size = num;
            capacity = size + 1;
            buffer = alloc.allocate(capacity * sizeof(char));
            this->alloc = alloc;

            if (buffer) {
                for (int i = 0; i < num; i++) {
                    buffer[i] = other;
                }
                buffer[num] = 0;
            } else {
                string();
            }
        }

        string(const string &other, const allocator<char> &alloc) noexcept: capacity(other.capacity), size(other.size) {
            this->alloc = alloc;
            buffer = alloc.allocate(other.capacity * sizeof(char));

            if (buffer && other.buffer) {
                memcpy(buffer, other.buffer, other.capacity);
            } else {
                string();
            }
        }

        string(string &&other, const allocator<char> &alloc) noexcept: buffer(other.buffer), capacity(other.capacity),
                                                                       size(other.size) {
            this->alloc = alloc;
            this->alloc.deallocate(buffer);
            buffer = alloc.allocate(capacity * sizeof(char));
            memcpy(buffer, other.buffer, size);
            buffer[size] = 0;
            other = string();
        }

        string(const iterator &first, const iterator &last, const allocator<char> &alloc) noexcept {
            this->alloc = alloc;
            size = last - first;
            capacity = size + 1;
            buffer = alloc.allocate(capacity * sizeof(char));
            memcpy(buffer, first, size);
            buffer[size] = 0;
        }

        string &operator=(const string &other) noexcept {
            if (this != &other) {
                return *this;
            }
            alloc.deallocate(buffer);
            *this = string(other.begin(), other.end());
            return *this;
        }

        string &operator=(string &&other) noexcept: capacity(other.capacity), size(other.size) {
            if (this != &other) {
                alloc.deallocate(buffer);
                buffer = other.buffer;
                other.buffer = alloc.allocate(1 * sizeof(char));
                other.buffer[0] = 0;
                other.capacity = 1;
                other.size = 0;
            }
            return *this;
        }

        string &operator=(const char *other) noexcept {
            alloc.deallocate(buffer);
            *this = string(other);
            return *this;
        }

        string &operator=(const char other) noexcept {
            alloc.deallocate(buffer);
            *this = string(1, other);
            return *this;
        }

        friend const ostream &operator<<(const ostream &stream, const string &str) noexcept {
            stream << str.buffer;
            return stream;
        }

        friend const istream &operator>>(const istream &stream, string &str) noexcept {
            char buffer[BUFFER_SIZE];

            if (fgets(buffer, sizeof(buffer), stdin)) {
                const size_t len = strlen(buffer);

                if (buffer[len - 1] == '\n') {
                    buffer[len - 1] = '\0';
                }
                str = string(buffer, buffer + len);
            }
            return stream;
        }

        iterator begin() const noexcept { return iterator(buffer); }
        iterator end() const noexcept { return iterator(buffer + size); }
        reverse_iterator rbegin() const noexcept { return reverse_iterator(buffer + size - 1); }
        reverse_iterator rend() const noexcept { return reverse_iterator(buffer - 1); }
        const_iterator cbegin() const noexcept { return const_iterator(buffer); }
        const_iterator cend() const noexcept { return const_iterator(buffer + size); }
        const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(buffer + size - 1); }
        const_reverse_iterator crend() const noexcept { return const_reverse_iterator(buffer - 1); }

        string &append(const string &other);

        string &append(const string &other, size_t sub_pos, size_t sub_len);

        string &append(const char *other);

        string &append(const char *other, size_t num);

        string &append(size_t num, const char other);

        string &append(const iterator &first, const iterator &last);

        string &append(const string &other, size_t num);

        string &assign(const string &other);

        string &assign(const string &other, size_t sub_pos, size_t sub_len);

        string &assign(const char *other);

        string &assign(const char *other, size_t num);

        string &assign(size_t num, const char other);

        string &assign(const iterator &first, const iterator &last);

        string &assign(const string &other, size_t num);

        char &at(size_t num);

        const char &at(size_t num) const;

        char &back();

        const char *c_str();

        // size_t capacity();

        void clear();

        int compare(const string &other);

        int compare(size_t pos, size_t len, const string &other);

        int compare(size_t pos, size_t len, const string &str, size_t subpos, size_t sublen);

        int compare(const char *s);

        int compare(size_t pos, size_t len, const char *s);

        int compare(size_t pos, size_t len, const char *s, size_t n);

        size_t copy(const char *other, size_t len, size_t pos);

        char *data();

        bool empty();

        bool ends_with(const string &suffix);

        bool ends_with(const char *suffix);

        bool ends_with(char ch);

        iterator &erase(const_iterator &pos);

        iterator &erase(const_iterator &first, const_iterator &last);

        string &erase(size_t pos, size_t count);

        size_t find(const string &other, size_t pos);

        size_t find(const char *other, size_t pos);

        size_t find(const char *other, size_t pos, size_t count);

        size_t find(char ch, size_t pos);

        size_t find_first_not_of(const string &other, size_t pos);

        size_t find_first_not_of(const char *other, size_t pos);

        size_t find_first_not_of(const char *other, size_t pos, size_t count);

        size_t find_first_not_of(char ch, size_t pos);

        size_t find_first_of(const string &other, size_t pos);

        size_t find_first_of(const char *other, size_t pos);

        size_t find_first_of(const char *other, size_t pos, size_t count);

        size_t find_first_of(char ch, size_t pos);

        size_t find_last_not_of(const string &other, size_t pos);

        size_t find_last_not_of(const char *other, size_t pos);

        size_t find_last_not_of(const char *other, size_t pos, size_t count);

        size_t find_last_not_of(char ch, size_t pos);

        size_t find_last_of(const string &other, size_t pos);

        size_t find_last_of(const char *other, size_t pos);

        size_t find_last_of(const char *other, size_t pos, size_t count);

        size_t find_last_of(char ch, size_t pos);

        char &front();

        allocator<char> get_allocator();

        string &insert(size_t pos, const string &other);

        string &insert(size_t pos, const string &str, size_t sub_pos, size_t sub_len);

        string &insert(size_t pos, const char *other);

        string &insert(size_t pos, const char *other, size_t num);

        string &insert(size_t pos, size_t num, char ch);

        iterator insert(const_iterator first, char ch);

        iterator insert(const_iterator first, size_t num, char ch);

        iterator insert(const_iterator p, iterator first, iterator last);

        size_t length();

        void pop_back();

        void push_back(const char ch) {
            int a = 5;
            auto res = Dream::iterator(&a);
        }

        string &replace(const_iterator start, const_iterator end, const char *other);

        string &replace(const_iterator start, const_iterator end, const string &other);

        void reserve(const size_t new_capacity) noexcept {
            if (new_capacity > capacity) {
                if (char *new_buffer = alloc.allocate(new_capacity * sizeof(char))) {
                    memcpy(new_buffer, buffer, size + 1);
                    alloc.deallocate(buffer);
                    buffer = new_buffer;
                    capacity = new_capacity;
                }
            }
        }

        ~string() noexcept {
            if (buffer) {
                alloc.deallocate(buffer);
            }
            buffer = nullptr;
        }
    };


    constexpr ostream cout;
    constexpr istream cin;
    constexpr char endl = '\n';
}
