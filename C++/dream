#pragma once
#include <cstdio>
#include <cstdlib>
#include <cstring>
constexpr int BUFFER_SIZE = 1024;

namespace Dream {
    class ostream final {
        template<class T>
        constexpr const ostream &overload(const char *format, T value) const noexcept {
            printf(format, value);
            return *this;
        }

    public:
        constexpr const ostream &operator<<(const int value) const noexcept { return overload("%d", value); }
        constexpr const ostream &operator<<(const unsigned int value) const noexcept { return overload("%u", value); }
        constexpr const ostream &operator<<(const long int value) const noexcept { return overload("%ld", value); }
        constexpr const ostream &operator<<(const unsigned long int value) const noexcept { return overload("%lu", value); }
        constexpr const ostream &operator<<(const long long int value) const noexcept { return overload("%lld", value); }
        constexpr const ostream &operator<<(const unsigned long long int value) const noexcept { return overload("%llu", value); }
        constexpr const ostream &operator<<(const float value) const noexcept { return overload("%f", value); }
        constexpr const ostream &operator<<(const double value) const noexcept { return overload("%f", value); }
        constexpr const ostream &operator<<(const long double value) const noexcept { return overload("%Lf", value); }
        constexpr const ostream &operator<<(const char value) const noexcept { return overload("%c", value); }
        constexpr const ostream &operator<<(const char *value) const noexcept { return overload("%s", value); }
        constexpr const ostream &operator<<(const void *value) const noexcept { return overload("%p", value); }
    };


    class istream final {
        template<class T>
        constexpr const istream &overload(const char *format, T value) const noexcept {
            scanf(format, value);
            return *this;
        }

    public:
        constexpr const istream &operator>>(int &value) const noexcept { return overload("%d", &value); }
        constexpr const istream &operator>>(unsigned int &value) const noexcept { return overload("%u", &value); }
        constexpr const istream &operator>>(long int &value) const noexcept { return overload("%ld", &value); }
        constexpr const istream &operator>>(unsigned long int &value) const noexcept { return overload("%lu", &value); }
        constexpr const istream &operator>>(long long int &value) const noexcept { return overload("%lld", &value); }
        constexpr const istream &operator>>(unsigned long long int &value) const noexcept { return overload("%llu", &value); }
        constexpr const istream &operator>>(float &value) const noexcept { return overload("%f", &value); }
        constexpr const istream &operator>>(double &value) const noexcept { return overload("%lf", &value); }
        constexpr const istream &operator>>(long double &value) const noexcept { return overload("%Lf", &value); }
        constexpr const istream &operator>>(char &value) const noexcept { return overload("%c", &value); }
        constexpr const istream &operator>>(char *value) const noexcept { return overload("%s", value); }
        constexpr const istream &operator>>(void *value) const noexcept { return overload("%p", value); }
    };


    template<class T>
    class allocator {
    public:
        constexpr allocator() noexcept = default;
        [[nodiscard]] constexpr T *allocate(const size_t size) const noexcept { return (T *) malloc(size * sizeof(T)); }

        [[nodiscard]] constexpr bool reallocate(T *&ptr, const size_t size) const noexcept {
            if (T *res = (T *) realloc(ptr, size * sizeof(T))) {
                ptr = res;
                return true;
            }
            return false;
        }
        constexpr void deallocate(T *ptr) const noexcept { free(ptr); }
        constexpr void construct(T *ptr, const T value) const noexcept { *ptr = value; }
        constexpr void destroy(T *ptr) const noexcept { ptr->~T(); }
    };


    template<class T, class Child>
    class iterator {
    protected:
        T *ptr_ = nullptr;

    public:
        constexpr iterator() noexcept = default;
        constexpr iterator(const T *value) noexcept : ptr_((T *) value) {}
        constexpr iterator(const iterator &itr) noexcept : ptr_(itr.ptr_) {}

        constexpr Child operator+(const size_t offset) const noexcept { return ptr_ + offset; }
        constexpr Child operator-(const size_t offset) const noexcept { return ptr_ - offset; }
        constexpr size_t operator-(const iterator &other) const noexcept { return ptr_ - other.ptr_; }
        constexpr bool operator==(const iterator &itr) const noexcept { return ptr_ == itr.ptr_; }
        constexpr bool operator!=(const iterator &itr) const noexcept { return ptr_ != itr.ptr_; }
        constexpr T &operator*() const noexcept { return *ptr_; }
        constexpr operator const void *() const noexcept { return (const void *) ptr_; }

        constexpr Child &operator=(const T value) noexcept {
            *ptr_ = value;
            return *((Child *) this);
        }

        constexpr Child &operator=(const iterator &other) noexcept {
            if (this == &other) {
                return *((Child *) this);
            }
            ptr_ = other.ptr;
            return *((Child *) this);
        }

        constexpr Child &operator++() noexcept {
            ++ptr_;
            return *((Child *) this);
        }

        constexpr Child operator++(int) noexcept {
            Child temp = *((Child *) this);
            ++ptr_;
            return temp;
        }

        constexpr Child &operator--() noexcept {
            --ptr_;
            return *((Child *) this);
        }

        constexpr Child operator--(int) noexcept {
            Child temp = *((Child *) this);
            --ptr_;
            return temp;
        }

        constexpr Child &operator+=(const size_t offset) noexcept {
            ptr_ += offset;
            return *((Child *) this);
        }

        constexpr Child &operator-=(const size_t offset) noexcept {
            ptr_ -= offset;
            return *((Child *) this);
        }
    };


    template<class T, class Child>
    class reverse_iterator : public iterator<T, reverse_iterator<T, Child>> {
    protected:
        using iterator<T, reverse_iterator>::ptr_;

    public:
        using iterator<T, reverse_iterator>::iterator;

        constexpr Child &operator++() noexcept {
            --ptr_;
            return *this;
        }

        constexpr Child operator++(int) noexcept {
            Child temp = *this;
            --ptr_;
            return temp;
        }

        constexpr Child &operator--() noexcept {
            ++ptr_;
            return *this;
        }

        Child operator--(int) noexcept {
            Child temp = *this;
            ++ptr_;
            return temp;
        }

        constexpr Child &operator+=(const size_t offset) noexcept {
            ptr_ -= offset;
            return *this;
        }

        constexpr Child &operator-=(const size_t offset) noexcept {
            ptr_ += offset;
            return *this;
        }
    };


    class string {
        char *buffer_ = nullptr;
        size_t capacity_ = 0, size_ = 0;
        allocator<char> alloc_ = allocator<char>();

    public:
        class iterator final : public Dream::iterator<char, iterator> {
        public:
            using Dream::iterator<char, iterator>::iterator;
        };

        class reverse_iterator final : public Dream::reverse_iterator<char, reverse_iterator> {
        public:
            using Dream::reverse_iterator<char, reverse_iterator>::reverse_iterator;
        };

        class const_iterator final : public Dream::iterator<const char, const_iterator> {
        public:
            using iterator::iterator;
        };

        class const_reverse_iterator final : public Dream::reverse_iterator<const char, const_reverse_iterator> {
        public:
            using reverse_iterator::reverse_iterator;
        };

        constexpr string(const allocator<char> &alloc) noexcept : buffer_(nullptr), capacity_(0), size_(0), alloc_(alloc) {}
        constexpr string(const char *str, const size_t count, const allocator<char> &alloc) noexcept : string(str, str + count, alloc) {}
        constexpr string(const char *str, const allocator<char> &alloc = allocator<char>()) noexcept : string(str, str + strlen(str), alloc) {}
        constexpr string(const string &other) noexcept : string(other, allocator<char>()) {}
        constexpr string(string &&other) noexcept : buffer_(other.buffer_), capacity_(other.capacity_), size_(other.size_) { other = string(); }
        constexpr string(const string &other, const allocator<char> &alloc) noexcept : string(other.begin(), other.end(), alloc) {}
        constexpr string(const string &other, const size_t pos, const allocator<char> &alloc) noexcept :
            string(other.begin() + pos, other.end(), alloc) {}
        constexpr string(const string &other, const size_t pos, const size_t count) noexcept :
            string(other.begin() + pos, other.begin() + pos + count) {}
        constexpr string(const string &other, const size_t pos, const size_t count, const allocator<char> &alloc) noexcept :
            string(other.begin() + pos, other.begin() + pos + count) {}
        constexpr string() noexcept : string(allocator<char>()) {}
        constexpr string(string &&other, const allocator<char> &alloc) noexcept :
            buffer_(other.buffer_), capacity_(other.capacity_), size_(other.size_) {
            other = string(alloc);
        }

        constexpr string(const size_t num, const char ch, const allocator<char> &alloc = allocator<char>()) noexcept {
            size_ = num;
            capacity_ = size_ + 1;
            alloc_ = alloc;

            if ((buffer_ = alloc_.allocate(capacity_ * sizeof(char)))) {
                for (int i = 0; i < num; i++) {
                    buffer_[i] = ch;
                }
                buffer_[size_] = 0;
            } else {
                *this = string();
            }
        }

        constexpr string(const iterator &first, const iterator &last, const allocator<char> &alloc = allocator<char>()) noexcept {
            alloc_ = alloc;
            size_ = last - first;
            capacity_ = size_ + 1;

            if ((buffer_ = alloc_.allocate(capacity_ * sizeof(char)))) {
                memcpy(buffer_, first, size_);
                buffer_[size_] = 0;
            } else {
                *this = string();
            }
        }

        constexpr string(const string &&other, const size_t pos, const allocator<char> &alloc) noexcept {
            size_ = other.end() - other.begin() - pos;
            capacity_ = size_ + 1;

            if ((buffer_ = alloc.allocate(capacity_ * sizeof(char)))) {
                for (int i = 0; i < size_; i++) {
                    buffer_[i] = other.buffer_[i + pos];
                }
                buffer_[size_] = 0;
            }
            *this = string();
        }

        constexpr string &operator=(const char *str) noexcept { return *this = string(str); }
        constexpr string &operator=(const char ch) noexcept { return *this = &ch; }

        constexpr string &operator=(const string &other) noexcept {
            if (this == &other) {
                return *this;
            }
            alloc_.deallocate(buffer_);
            *this = string(other.begin(), other.end());
            return *this;
        }

        constexpr string &operator=(string &&other) noexcept {
            if (this == &other) {
                capacity_ = other.capacity_;
                size_ = other.size_;
                alloc_.deallocate(buffer_);
                buffer_ = other.buffer_;
                other.buffer_ = nullptr;
                other.capacity_ = other.size_ = 0;
            }
            return *this;
        }

        constexpr friend const ostream &operator<<(const ostream &stream, const string &str) noexcept {
            stream << str.buffer_;
            return stream;
        }

        constexpr friend const istream &operator>>(const istream &stream, string &str) noexcept {
            char buffer[BUFFER_SIZE];

            if (fgets(buffer, sizeof(buffer), stdin)) {
                const size_t len = strlen(buffer);

                if (buffer[len - 1] == '\n') {
                    buffer[len - 1] = 0;
                }
                str = string(buffer, buffer + len);
            }
            return stream;
        }

        constexpr operator bool() const noexcept { return buffer_ != nullptr; }

        [[nodiscard]] constexpr iterator begin() const noexcept { return buffer_; }
        [[nodiscard]] constexpr iterator end() const noexcept { return buffer_ + size_; }
        [[nodiscard]] constexpr reverse_iterator rbegin() const noexcept { return buffer_ + size_ - 1; }
        [[nodiscard]] constexpr reverse_iterator rend() const noexcept { return buffer_ - 1; }
        [[nodiscard]] constexpr const_iterator cbegin() const noexcept { return buffer_; }
        [[nodiscard]] constexpr const_iterator cend() const noexcept { return buffer_ + size_; }
        [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept { return buffer_ + size_ - 1; }
        [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept { return buffer_ - 1; }

        string &append(const size_t num, const char ch) noexcept { return this->append(string(num, ch)); }
        string &append(const char *str, const size_t len) noexcept { return this->append(str, str + len); }
        string &append(const char *str) noexcept { return this->append(str, str + strlen(str)); }
        string &append(const string &other) noexcept { return this->append(other.begin(), other.end()); }
        string &append(const string &other, const size_t sub_pos, const size_t sub_len = (other.end() - other.begin())) noexcept {
            return this->append(other.begin() + sub_pos, other.begin() + sub_pos + sub_len);
        }

        string &append(const iterator &first, const iterator &last) noexcept {
            const size_t len = last - first;

            if (len && alloc_.reallocate(buffer_, (size_ + len + 1) * sizeof(char))) {
                size_t i = size_;
                iterator itr = first;

                while (itr != last) {
                    buffer_[i] = *itr;
                    ++itr;
                    ++i;
                }
                size_ += len;
                capacity_ = size_ + 1;
                buffer_[size_] = 0;
            }
            return *this;
        }

        string &assign(const string &other);
        string &assign(const string &&other);
        string &assign(size_t num, const char other);
        string &assign(const char *other, size_t num);
        string &assign(const char *other) string &assign(const string &other, const size_t sub_pos,
                                                         const size_t sub_len = (other.end() - other.begin())) {
            return *this = string(other, sub_pos, sub_len);
        }
        string &assign(const iterator &first, const iterator &last) { return *this = string(first, last); }

        char &at(size_t num);

        const char &at(size_t num) const;

        char &back();

        const char *c_str();

        // size_t capacity();

        void clear();

        int compare(const string &other);

        int compare(size_t pos, size_t len, const string &other);

        int compare(size_t pos, size_t len, const string &str, size_t subpos, size_t sublen);

        int compare(const char *s);

        int compare(size_t pos, size_t len, const char *s);

        int compare(size_t pos, size_t len, const char *s, size_t n);

        size_t copy(const char *other, size_t len, size_t pos);

        char *data();

        bool empty();

        bool ends_with(const string &suffix);

        bool ends_with(const char *suffix);

        bool ends_with(char ch);

        iterator &erase(const_iterator &pos);

        iterator &erase(const_iterator &first, const_iterator &last);

        string &erase(size_t pos, size_t count);

        size_t find(const string &other, size_t pos);

        size_t find(const char *other, size_t pos);

        size_t find(const char *other, size_t pos, size_t count);

        size_t find(char ch, size_t pos);

        size_t find_first_not_of(const string &other, size_t pos);

        size_t find_first_not_of(const char *other, size_t pos);

        size_t find_first_not_of(const char *other, size_t pos, size_t count);

        size_t find_first_not_of(char ch, size_t pos);

        size_t find_first_of(const string &other, size_t pos);

        size_t find_first_of(const char *other, size_t pos);

        size_t find_first_of(const char *other, size_t pos, size_t count);

        size_t find_first_of(char ch, size_t pos);

        size_t find_last_not_of(const string &other, size_t pos);

        size_t find_last_not_of(const char *other, size_t pos);

        size_t find_last_not_of(const char *other, size_t pos, size_t count);

        size_t find_last_not_of(char ch, size_t pos);

        size_t find_last_of(const string &other, size_t pos);

        size_t find_last_of(const char *other, size_t pos);

        size_t find_last_of(const char *other, size_t pos, size_t count);

        size_t find_last_of(char ch, size_t pos);

        char &front();

        allocator<char> get_allocator();

        string &insert(size_t pos, const string &other);

        string &insert(size_t pos, const string &str, size_t sub_pos, size_t sub_len);

        string &insert(size_t pos, const char *other);

        string &insert(size_t pos, const char *other, size_t num);

        string &insert(size_t pos, size_t num, char ch);

        iterator insert(const_iterator first, char ch);

        iterator insert(const_iterator first, size_t num, char ch);

        iterator insert(const_iterator p, iterator first, iterator last);

        size_t length();

        void pop_back();

        void push_back(const char ch);

        string &replace(const_iterator start, const_iterator end, const char *other);

        string &replace(const_iterator start, const_iterator end, const string &other);

        constexpr void reserve(const size_t new_capacity) noexcept {
            if (new_capacity > capacity_) {
                if (char *new_buffer = alloc_.allocate(new_capacity * sizeof(char))) {
                    memcpy(new_buffer, buffer_, size_ + 1);
                    alloc_.deallocate(buffer_);
                    buffer_ = new_buffer;
                    capacity_ = new_capacity;
                }
            }
        }

        ~string() noexcept {
            if (buffer_) {
                alloc_.deallocate(buffer_);
            }
            buffer_ = nullptr;
        }
    };


    constexpr ostream cout;
    constexpr istream cin;
    constexpr char endl = '\n';
} // namespace Dream
